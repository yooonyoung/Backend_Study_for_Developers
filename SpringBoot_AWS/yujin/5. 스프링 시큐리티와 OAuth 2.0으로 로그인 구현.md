### 스프링 시큐리티

막강한 인증과 인과(혹인 권한 부여) 기능을 가진 프레임워크

스프링 기반의 애플리케이션에서는 보안을 위한 표준

## 5.1 스프링 시큐리티와 스프링 시큐리티 Oauth2 클라이언트

### OAuth

소셜 로그인으로, 페이스북, 깃허브, 트위터, 네이버, 카카오등.. 제공한다

 **spring-security-oauth2-autoconfigure 라이브러리** 

스프링 부트 1.5에서 쓰던 설정을 스프링 부트 2.0에서도 사용 가능하게 해준다

**Spring Security Oatuh2 Client 라이브러리**

스프링 부트 2 방식으로, 여기서는 이 라이브러리 사용한다

그 이유는

- 스프링 팀에서 기존 1.5에서 사용되던 spring-security-oauth 프로젝트는 유지 상태로 결정했으며 더는 신규 기능은 추가하지 않고 버그 수정 정도의 기능만 추가될 예정이라고 선언함
- 스프링 부트용 라이브러리 출시
- 기존에 사용되던 방식은 확장 포인트가 적절하게 오픈되어 있지 않아 직접 상속하거나 오버라딩 해야 하고 신규 라이브러리의 경우 확장 포인트를 고려해서 설계된 상태

## 5.2 구글 서비스 등록

서비스 생성과 인증 정보 발급은 생략하겠습니다.

### 1. 클라이언트 ID와 클라이언트 보안 비밀코드를 프로젝트에 설정

**1. application-oauth.properties 등록**

src/main/resources/에 application-oauth.properties 파일 생성

~~~
spring.security.oauth2.client.registration.google.client-id=클라이언트 ID
spring.security.oauth2.client.registration.google.client-secret=클라이언트 보안 비밀번호
spring.security.oauth2.client.registration.google.scope=profile,email
~~~

- **scope=profile,email**
  - 많은 예제에서는 이 scope를 별도로 등록x
  - 기본값이 openid,profile,email이기 때문
  - 강제로 profile,email를 등록한 이유는 openid라는 scope가 있으면 Open id Provider로 인식하기 때문
  - 이렇게 되면 Open id Provider인 서비스(구글)와 그렇지 않은 서비스(네이버/카카오 등)로 나눠서 각각 OAuth2Service를 만들어야 함
  - **하나의 OAuth2Service로 사용하기 위해 일부러 openid scope를 빼고 등록**



**2. application.properties 추가**

profile=xxx식으로 호출하면 해당 properties 설정 가져올 수 있음

~~~
spring.profiles.include=oauth
~~~

**3. gitignore 등록**

보안을 위해 깃허브에 application-oauth.properties 파일이 올라가는 것을 방지

**커밋 파일 목록에 application-oauth.properties**가 나오지 않으면 성공

~~~
application-oauth.properties
~~~



## 5.3 구글 로그인 연동

### 1. 사용자 정보 User 클래스 생성

domain 아래 user 패키지 아래에 생성

~~~java
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

import javax.persistence.*;

@Getter
@NoArgsConstructor
@Entity
public class User { // 사용자 정보를 담당
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false)
    private String email;
    
    @Column
    private String picture;
    
    @Enumerated(EnumType.STRING) //1
    @Column(nullable = false)
    private Role role;
    
    @Builder
    public User(String name, String email, String picture, Role role){
        this.name = name;
        this.email = email;
        this.picture = picture;
        this.role = role;
    }
    
    public User update(String name, String picture){
        this.name = name;
        this.picture = picture;
        return this;
    }
    public String getRoleKey() {
        return this.role.getKey();
    }
}
~~~

**1. @Enumerated(EnumType.STRING)**

- JPA로 데이터베이스로 저장할 때 Enum 값을 어떤 형태로 저장할지를 결정

- 기본적으로 int로 숫자가 저장되는데, 여기서는 문자열(EnumType.STRING)로 지정

- 숫자로 저장되면 데이터베이스로 확인할 때 그 값이 무슨 코드를 의미하는지 모름.

  

### 2. 사용자 권한 관리할 Enum 클래스 Role 생성

domain/user패키지 아래에 생성

~~~java
package com.yujin.service.springboot.domain.user;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Role { // 사용자 권한 관리 enum 클래스
    GUEST("ROLE_GUEST", "손님"), //ROLE_ 시작하는 것은 코드별 키 값
    USER("ROLE_USER", "일반 사용자");
    private final String key;
    private final String title;

}
~~~

스프링 시큐리티에서는 권한 코드에 항상 **ROLE_이 앞에 있어야**

그래서 코드별 키 값을 ROLE_GUEST, ROLE_USER 등으로 지정

### 3. User의 CRUD 책임질 UserRepository 인터페이스 생성

domain/user패키지 아래에 생성

~~~java
package com.yujin.service.springboot.domain.user;

import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email); //1
}

~~~

1. **findByEmail**
   - 소셜 로그인으로 반환되는 값 중 email을 통해 이미 생성된 사용자인지 처음 가입하는 사용자인지 판단하기 위한 메소드

#### 여기까지(1,2,3)가 User 엔티티 관련 코드

### 4. 스프링 시큐리티 설정

#### 1. build.gradle에 스프링 시큐리티 관련 의존성 하나를 추가

~~~
compile('org.springframework.boot:spring-boot-starter-oauth2-client')
~~~

#### 2. OAuth 소셜 로그인 설정 코드 작성

- config.auth 패키지 생성
  - **시큐리티 관련 클래스는 모두 이곳에** 생성

**SecurityConfig 클래스 생성**

~~~java
import com.yujin.service.springboot.domain.user.Role;
import lombok.RequiredArgsConstructor;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;


@RequiredArgsConstructor
@EnableWebSecurity //1
public class SecurityConfig {

    private final CustomOAuth2UserService customOAuth2UserService;

    @Override
    protected void configure(HttpSecurity http) throws Exception{
        http
                .csrf().disable()
                .headers().frameOptions().disable() //2
                .and()
                    .authorizeRequests() //3
                    .antMatchers("/", "/css/**", "/images/**",
                            "/js/**", "/h2-console/**").permitAll()
                    .antMatchers("/api/v1/**").hasRole(Role.
                    USER.name()) //4
                    .anyRequest().authenticated() //5
                .and()
                    .logout()
                        .logoutSuccessUrl("/") //6
                .and()
                    .oauth2Login() //7
                        .userInfoEndpoint() //8
                            .userService(customOAuth2UserService); //9
    }
}
~~~

1. **@EnableWebSecurity**

   - Spring Security 설정들을 활성화

2. **.csrf().disable().headers().frameOptions().disable()**

   - h2-console 화면을 사용하기 위해 해당 옵션들을 disable 

3. **authorizeRequests**

   - URL별 권한 관리를 설정하는 옵션의 시작점
   - authorizeRequests가 선언되어야만 antMatchers 옵션을 사용 가능

4. **antMatchers**

   - **권한 관리 대상**을 지정하는 옵션
   - `URL, HTTP 메소드별로 관리`가 가능합니다.
   - "/"등 지정된 URL들은 permitAll() 옵션을 통해 전체 열람 권한
   - "/api/v1/**"주소를 가진 API는 USER 권한을 가진 사람만 가능

5. **anyRequest**

   - 설정된 값들 이외 나머지 URL
   - 여기서는 authenticated()을 추가하여 나머지 URL들은 모두 인증된 사용자들에게만 허용

6. **logout().logoutSuccessUrl("/")**

   - 로그아웃 기능에 대한 여러 설정의 진입점
   - 로그아웃 성공 시 / 주소로 이동

7. **oauth2Login**

   - OAuth 2 로그인 기능에 대한 여러 설정의 진입점

8. **userInfoEndpoint**

   - OAuth 2 로그인 성공 이후 사용자 정보를 가져올 때의 설정들을 담당

9. **userService**

   - 소셜 로그인 성공 시 후속 조치를 진행할 UserService 인터페이스의 구현체를 등록

   - 리소스 서버(즉, 소셜 서비스들)에서 사용자 정보를 가져온 상태에서 추가로 

     진행하고자 하는 기능을 명시 가능

#### 3. customOAuth2UserService 클래스 생성

구글 로그인 이후 가져온 사용자의 정보(email,name,picture등) 들을 기반으로 

가입 및 정보수정, 세션 저장 등의 기능을 지원

마찬가지로 config.auth 내에 클래스 생성

~~~

~~~

